<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>[译]Learning Go - from zero to hero - KeepLearning</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "[\u8bd1]Learning Go - from zero to hero";
        var mkdocs_page_input_path = "go/[\u8bd1]Learning Go - from zero to hero.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> KeepLearning
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">一个大专🐶的学习记录</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">C++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="#">C++学习笔记</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HelloWorld/">HelloWorld</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Reference/">Reference</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/">函数</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">动态内存</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F/">变量和常量</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/">命名空间</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BC%95%E7%94%A8/">引用</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8C%87%E9%92%88/">指针</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%9A%E4%B8%BE/">枚举</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A8%A1%E6%9D%BF-%E6%B3%9B%E5%9E%8B/">模板 泛型</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%A8%E9%87%8A/">注释</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%80%E4%BB%8B/">简介</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6%E5%92%8C%E9%81%8D%E5%8E%86/">逻辑控制和遍历</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%2B%2B/C%2B%2B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">CSS</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../CSS/Reference/">Reference</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Css3学习笔记</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2D%E8%BD%AC%E6%8D%A2/">2D转换</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/3D%E8%BD%AC%E6%8D%A2/">3D转换</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8A%A8%E7%94%BB/">动画</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%89%87/">图片</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%9A%E5%88%97/">多列</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93/">字体</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8C%89%E9%92%AE/">按钮</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%9C%AC%E6%95%88%E6%9E%9C/">文本效果</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B8%90%E5%8F%98/">渐变</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2/">用户界面</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%9B%92%E9%98%B4%E5%BD%B1/">盒阴影</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%83%8C%E6%99%AF/">背景</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BE%B9%E6%A1%86%E5%9B%BE%E7%89%87/">边框图片</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BE%B9%E6%A1%86%E5%9C%86%E8%A7%92/">边框圆角</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%87%E6%B8%A1/">过渡</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Css学习笔记</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BC%AA%E7%B1%BB/">伪类</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%86%85%E8%BE%B9%E8%B7%9D/">内边距</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E7%BB%84%E9%80%89%E6%8B%A9%E5%99%A8/">分组选择器</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%97%E8%A1%A8%E6%A0%B7%E5%BC%8F/">列表样式</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/">响应式设计</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A4%96%E8%BE%B9%E8%B7%9D/">外边距</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/">媒体查询</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93/">字体</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9A%E4%BD%8D/">定位</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B0%BA%E5%AF%B8/">尺寸</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%A5%97%E9%80%89%E6%8B%A9%E5%99%A8/">嵌套选择器</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%9C%AC/">文本</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%98%BE%E7%A4%BA%E5%92%8C%E5%8F%AF%E8%A7%81%E6%80%A7/">显示和可见性</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A0%B7%E5%BC%8F%E8%A1%A8/">样式表</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%A8%E9%87%8A/">注释</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B5%AE%E5%8A%A8/">浮动</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/">盒子模型</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%80%E4%BB%8B/">简介</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8/">组合选择器</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BD%91%E6%A0%BC%E8%A7%86%E5%9B%BE/">网格视图</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%83%8C%E6%99%AF/">背景</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A1%A8%E6%A0%BC/">表格</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AF%AD%E6%B3%95/">语法</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BD%AE%E5%BB%93/">轮廓</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BE%B9%E6%A1%86/">边框</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%89%E6%8B%A9%E5%99%A8/">选择器</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%93%BE%E6%8E%A5/">链接</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../CSS/css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%A2%9C%E8%89%B2%E7%9A%84%E5%86%99%E6%B3%95/">颜色的写法</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">C语言</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="#">C语言学习笔记</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/HelloWorld/">HelloWorld</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Reference/">Reference</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BD%8D%E8%BF%90%E7%AE%97/">位运算</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0/">函数</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%98%E9%87%8F/">变量</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E9%87%8F/">常量</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8C%87%E9%92%88/">指针</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">数据类型</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84/">数组</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9E%9A%E4%B8%BE/">枚举</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B3%A8%E9%87%8A/">注释</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%AE%80%E4%BB%8B/">简介</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Docker</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../Docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Docker学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Shell</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="#">Shell学习笔记</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.%E7%AE%80%E4%BB%8B/">简介</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.%E6%B3%A8%E9%87%8A/">注释</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/03.%E5%8F%98%E9%87%8F/">变量</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/04.%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05.%E6%95%B0%E7%BB%84/">数组</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/06.%E8%BF%90%E7%AE%97%E7%AC%A6/">运算符</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/07.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/">流程控制</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/08.%E5%87%BD%E6%95%B0/">函数</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/09.%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/">输入和输出</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E5%90%91Shell%E8%84%9A%E6%9C%AC%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/">向Shell脚本传递参数</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/11.%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/">文件包含</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../Shell/shell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/12.Shell%E5%B7%A5%E5%85%B7/">Shell工具</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Git</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../git/Git%E9%80%9F%E6%9F%A5%E8%A1%A8/">Git速查表</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Go</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">[译]Learning Go - from zero to hero</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_1">入门</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#workspace">工作区（Workspace）</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#helloworld">HelloWorld</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#variables">变量（variables）</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#data-types">数据类型（Data types）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#numberstring-boolean">数字，字符串，布尔（Number，String， Boolean）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#arraysslicesmaps">数组，切片，映射（Arrays，Slices，Maps）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_2">类型强转</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_3">条件语句</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#if-else">if else</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#switch-case">switch case</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_4">循环</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">指针</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_6">函数</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#method-structs-and-interfaces">方法，结构，接口（Method, Structs, and Interfaces）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#struct">结构（struct）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#method">方法（method）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#interface">接口（interface）</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#packages">包（packages）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_7">安装包</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">创建自定义的包</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#packages-documentation">包文档（Packages Documentation）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#go">Go中的一些内置包</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#fmt">fmt</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#json">json</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#error-handling">错误处理（Error Handling）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_9">给函数返回自定义的错误类型</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#panic">恐慌（panic）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#defer">延迟（defer）</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#concurrency">并发（Concurrency）</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#routine">协程（routine）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#channels">通道（Channels）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#one-way-channel">单向的通道（One Way Channel）</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#selectgo-routinechannel">使用select为Go routine组织多个channel</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#buffered-channel">带缓冲的通道（Buffered channel）</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#great">Great!</a>
    </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Groovy</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../groovy/Groovy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Groovy学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Html</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../html/HTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">HTML5学习笔记</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../html/HTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">HTML学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Javascript</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../javascript/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">基本语法</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Mysql</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../mysql/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">MySQL学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Python</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../python/Python%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Python学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">数据结构</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8-list/">线性表-List</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E6%A0%88-stack/">栈-Stack</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E9%98%9F%E5%88%97-queue/">队列-queue</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E5%AD%97%E7%AC%A6%E4%B8%B2-string/">字符串-string</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">算法</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../%E7%AE%97%E6%B3%95/10%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大经典排序算法</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">英语</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">语法学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">计算机网络</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">计算机网络学习笔记</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">设计模式</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">设计模式学习笔记</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">KeepLearning</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>Go &raquo;</li><li>[译]Learning Go - from zero to hero</li>
    <li class="wy-breadcrumbs-aside">
        <a href="https://github.com/simplepeng/KeepLearning/edit/master/docs/go/[译]Learning Go - from zero to hero.md"
          class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="learning-go-from-zero-to-hero">[译]Learning Go - from zero to hero</h1>
<p><a href="https://medium.freecodecamp.org/learning-go-from-zero-to-hero-d2a3223b3d86">原文链接</a></p>
<p>让我们从Go（或Golang）的一个小介绍开始。Go由Google工程师Robert Griesemer，Rob Pike和Ken Thompson设计，它是一种静态类型的编译语言。第一个版本于2012年3月作为开源发布。</p>
<blockquote>
<p>“Go是一种开源编程语言，可以轻松构建简单，可靠，高效的软件”</p>
<p>​ ——GoLang</p>
</blockquote>
<p>在许多语言中，有许多方法可以解决给定的问题。程序员可能花很多时间去思考解决问题的最佳方法。</p>
<p>另一方面，Go相信更少的功能 - 只有一种正确的方法来解决问题。这节省了开发人员的时间，并使大型代码库易于维护。</p>
<p>Go中没有像<code>maps</code>和<code>filters</code>这种富有表现力的功能。</p>
<blockquote>
<p>“当你使用这种富有表现力的功能时，通常会带来额外的负担”</p>
<p>​ ——Rob Pike</p>
</blockquote>
<h2 id="_1">入门</h2>
<p>Go由包组成。<code>main</code>包告诉Go编译器程序被编译为可执行文件，而不是共享库。它是应用程序的入口点。</p>
<pre><code class="language-go">package main
</code></pre>
<p>让我们通过在Go工作区中创建一个文件<code>main.go</code>来编写一个简单的hello world示例</p>
<h2 id="workspace">工作区（Workspace）</h2>
<p>Go中的Workspace由环境变量<code>GOPATH</code>定义</p>
<p>您编写的任何代码都将写入工作区内，Go将搜索<code>GOPATH</code>目录中的任何包，或者在安装Go时默认设置的<code>GOROOT</code>目录。<code>GOROOT</code>是安装go的路径。</p>
<p>将GOPATH设置为所需的目录。现在，让我们将其添加到文件夹中<code>~/workspace</code>。</p>
<pre><code class="language-shell"># export env
export GOPATH=~/workspace
# go inside the workspace directory
cd ~/workspace
</code></pre>
<p>在<code>workspace</code>目录下创建<code>main.go</code></p>
<h2 id="helloworld">HelloWorld</h2>
<pre><code class="language-go">package main

import(
    &quot;fmt&quot;
)

func main(){
    fmt.Println(&quot;Hello World&quot;)
}
</code></pre>
<p>在上面这个例子中，<code>fmt</code>是Go中的内置包，它实现了格式化I / O的功能。</p>
<p>我们使用关键字<code>import</code>导入一个包。<code>func main</code>是代码执行的入口点。<code>Println</code>是<code>fmt</code>包中的一个函数，它为我们打印<code>Hello Wrold</code>。</p>
<p>让我们看一下运行这个文件。我们可以通过两种方式运行Go命令。我们知道，Go是一种编译语言，所以我们首先需要在执行之前编译它。</p>
<pre><code class="language-shell">&gt; go build main.go
</code></pre>
<p>这将创建一个二进制可执行文件main，现在我们可以运行它</p>
<pre><code class="language-shell"> &gt; ./main
 # Hello World!
</code></pre>
<p>还有另一种更简单的方法来运行程序。<code>go run</code>命令有助于抽象编译步骤。您只需运行以下命令即可执行该程序。</p>
<pre><code class="language-shell">&gt; go run main.go
 # Hello World!
</code></pre>
<p><a href="https://play.golang.org/">在线运行Go代码   https://play.golang.org/</a></p>
<h2 id="variables">变量（variables）</h2>
<p>变量在Go中是明确类型的，Go是一门静态类型语言。这意味着在变量声明时会检查变量类型，变量可以声明为：</p>
<pre><code class="language-go">var a int
</code></pre>
<p>在这种情况下，这个变量被设置为0。使用以下语法声明和初始化具有不同值的变量：</p>
<pre><code class="language-go">var a = 1
</code></pre>
<p>这里的变量a被自动指定为int类型。我们还可以使用变量声明的简写定义：</p>
<pre><code class="language-go">message := &quot;hello world&quot;
</code></pre>
<p>我们也可以在同一行中声明多个变量:</p>
<pre><code class="language-go">var b,c int = 2,3
</code></pre>
<p><strong>tips：在go中声明变量后面可以不用分号结尾，go采用类型后置声明法</strong></p>
<h2 id="data-types">数据类型（Data types）</h2>
<p>像其他语言一样，Go也支持各种不同的数据结构。我们来探讨其中一些：</p>
<h3 id="numberstring-boolean">数字，字符串，布尔（Number，String， Boolean）</h3>
<p>一些受支持的数字存储类型是<code>int</code>,<code>int8</code>,<code>int16</code>,<code>int32</code>,<code>int64</code>,<code>uint</code>,<code>uint8</code>,<code>uint16</code>,<code>uint32</code>,<code>uintptr</code>...</p>
<p>字符串类型存储一系列字节,它用关键字<code>string</code>表示和声明。</p>
<p>使用关键字<code>bool</code>存储布尔值。</p>
<p>Go还支持复数类型数据类型吗，可以用<code>complex64</code>和<code>complex128</code>声明。</p>
<pre><code class="language-go">var a bool = true
var b int = 1
var c string = 'hello world'
var d float32 = 1.222
var x complex128 = cmplx.Sqrt(-5 + 12i)
</code></pre>
<h3 id="arraysslicesmaps">数组，切片，映射（Arrays，Slices，Maps）</h3>
<p>数组是相同数据类型的元素序列，数组在声明时需要定义数组的长度，所有它不能扩容。数组声明为：</p>
<pre><code class="language-go">var a [5]int
</code></pre>
<p>数组也可以声明为多维数组：</p>
<pre><code class="language-go">var multiD [2][3]int
</code></pre>
<p>当数组的值需要在运行时更改时，数组限制了这种情况。数组也不提供获取子数组的能力。为此，Go有一个名为<code>slices</code>的数据类型。</p>
<p><code>Slices</code>存储一系列元素，可以随时扩展。切片声明类似于数组声明。只是没有定义数组的容量。</p>
<pre><code class="language-go">var b []int
</code></pre>
<p>这将创建一个零容量，零长度的切片。切片也可以定义容量和长度。我们可以使用以下语法：</p>
<pre><code class="language-go">numbers := make([]int,5,10)
</code></pre>
<p>在这里，切片的初始长度为5，容量为10。</p>
<p>切片是数组的抽象，切片使用数组作为底层结构，切片包含三个组件：容量，长度和指向底层数组的指针。</p>
<p>通过使用append或copy函数可以增加切片的容量。 append函数可以为数组的末尾添加值，并在需要时增加容量。</p>
<pre><code class="language-go">numbers = append(numbers, 1, 2, 3, 4)
</code></pre>
<p>增加切片容量的另一种方法是使用复制功能，只需创建另一个具有更大容量的切片，然后将原始切片复制到新创建的切片。</p>
<pre><code class="language-go">// create a new slice
number2 := make([]int, 15)
// copy the original slice to new slice
copy(number2, number)
</code></pre>
<p>我们可以创建切片的子切片。这可以使用以下命令简单地完成：</p>
<pre><code class="language-go">// initialize a slice with 4 len and values
number2 = []int{1,2,3,4}
fmt.Println(numbers) // -&gt; [1 2 3 4]
// create sub slices
slice1 := number2[2:]
fmt.Println(slice1) // -&gt; [3 4]
slice2 := number2[:3]
fmt.Println(slice2) // -&gt; [1 2 3]
slice3 := number2[1:4]
fmt.Println(slice3) // -&gt; [2 3 4]
</code></pre>
<p><code>map</code>是Go中的数据类型，它将<code>键</code>映射到<code>值</code>。我们可以使用以下命令定义map：</p>
<pre><code class="language-go">var m map[string]int
</code></pre>
<p>这里m是新的map变量，它的键为字符串，值为整数。我们可以轻松地将键和值添加到map中：</p>
<pre><code class="language-go">m['clearity'] = 2
m['simplicity'] = 3
// printing the values
fmt.Println(m['clearity']) // -&gt; 2
fmt.Println(m['simplicity']) // -&gt; 3
</code></pre>
<h3 id="_2">类型强转</h3>
<p>可以使用类型转换将一种类型的数据类型转换为另一种类型，我们来看一个简单的类型转换：</p>
<pre><code class="language-go">a := 1.1
b := int(a)
fmt.Println(b)
//-&gt; 1
</code></pre>
<p>并非所有类型的数据类型都可以转换为其他类型，确保数据类型与转换类型是否兼容。</p>
<h2 id="_3">条件语句</h2>
<h3 id="if-else">if else</h3>
<p>对于条件语句，我们可以使用if-else语句，如下例所示。确保花括号与条件位于同一行。</p>
<pre><code class="language-go">if num := 9; num &lt; 0 {
 fmt.Println(num, &quot;is negative&quot;)
} else if num &lt; 10 {
 fmt.Println(num, &quot;has 1 digit&quot;)
} else {
 fmt.Println(num, &quot;has multiple digits&quot;)
}
</code></pre>
<p><strong>tips：go中的代码块括号不换行，并且条件判断的表达式不加括号</strong></p>
<h3 id="switch-case">switch case</h3>
<p>switch case 有助于组织多个条件语句，以下示例显示了一个简单的switch case语句：</p>
<pre><code class="language-go">i := 2
switch i {
case 1:
 fmt.Println(&quot;one&quot;)
case 2:
 fmt.Println(&quot;two&quot;)
default:
 fmt.Println(&quot;none&quot;)
}
</code></pre>
<h2 id="_4">循环</h2>
<p>go只有一个关键字<code>for</code>来实现循环操作</p>
<pre><code class="language-go">i := 0
sum := 0
for i &lt; 10 {
 sum += 1
  i++
}
fmt.Println(sum)
</code></pre>
<p>上面的这个例子类似于C语言中的<code>while</code>循环，相同的for语句可用于正常for循环：</p>
<pre><code class="language-go">sum := 0
for i := 0; i &lt; 10; i++ {
  sum += i
}
fmt.Println(sum)
</code></pre>
<p>Go中的无限循环：</p>
<pre><code class="language-go">for {
}
</code></pre>
<h2 id="_5">指针</h2>
<p>Go也提供了指针变量，指针是保存值地址的变量。指针用<code>*</code>号定义，根据数据类型定义指针</p>
<pre><code class="language-go">var ap *int
</code></pre>
<p>这里的<code>ap</code>是指向整数类型的指针，<code>＆</code>运算符（取地址符）可用于获取变量的地址。</p>
<pre><code class="language-go">a := 12
ap = &amp;a
</code></pre>
<p>可以使用<code>*运算符</code>访问指针指向的值：</p>
<pre><code class="language-go">fmt.Println(*ap)
// =&gt; 12
</code></pre>
<p>指针通常在当<strong>将结构作为参数传递</strong>或者为<strong>已定义的类型声明方法</strong>时使用</p>
<ol>
<li>
<p>值传递时，复制的值意味着消耗更多的内存</p>
</li>
<li>
<p>传递指针后，函数更改的值将反映在方法/函数调用者中</p>
</li>
</ol>
<pre><code class="language-go">func increment(i *int) {
  *i++
}
func main() {
  i := 10
  increment(&amp;i)
  fmt.Println(i)
}
//=&gt; 11
</code></pre>
<p>注意：在博客中尝试示例代码时，不要忘记将其包含在main包中，并在需要时导入fmt或其他包，如上面第一个main.go示例所示。</p>
<h2 id="_6">函数</h2>
<p>main函数是被定义在main包下的主程序的入口。当然我们自己也可以定义更多的函数来使用。</p>
<pre><code class="language-go">func add(a int, b int) int {
  c := a + b
  return c
}
func main() {
  fmt.Println(add(2, 1))
}
//=&gt; 3
</code></pre>
<p>正如我们在上面的例子中看到的那样，使用<code>func</code>关键字后跟函数名定义Go函数。函数所需的参数需要根据其数据类型定义，最后是返回的数据类型。</p>
<p>函数的返回也可以在函数中预定义：</p>
<pre><code class="language-go">func add(a int, b int) (c int) {
  c = a + b
  return
}
func main() {
  fmt.Println(add(2, 1))
}
//=&gt; 3
</code></pre>
<p>这里c被定义为返回变量。因此，定义的变量c将自动返回，而无需在结尾的return语句中定义。</p>
<p>您还可以从使用逗号分隔返回值的单个函数返回多个返回值：</p>
<pre><code class="language-go">func add(a int, b int) (int, string) {
  c := a + b
  return c, &quot;successfully added&quot;
}
func main() {
  sum, message := add(2, 1)
  fmt.Println(message)
  fmt.Println(sum)
}
</code></pre>
<h2 id="method-structs-and-interfaces">方法，结构，接口（Method, Structs, and Interfaces）</h2>
<p>Go不是一种完全面向对象的语言，但是对于结构，接口和方法，它有很多面向对象的支持和感觉。</p>
<h3 id="struct">结构（struct）</h3>
<p>结构是不同字段的类型集合，结构用于将数据组合在一起。例如，如果我们想要定义Person类型的数据组合，我们会定义一个人的属性，其中可能包括姓名，年龄，性别。可以使用以下语法定义结构：</p>
<pre><code class="language-go">type person struct {
  name string
  age int
  gender string
}
</code></pre>
<p>在定义了person类型结构的情况下，现在让我们创建一个person对象：</p>
<pre><code class="language-go">//way 1: specifying attribute and value
p = person{name: &quot;Bob&quot;, age: 42, gender: &quot;Male&quot;}
//way 2: specifying only value
person{&quot;Bob&quot;, 42, &quot;Male&quot;}
</code></pre>
<p>我们可以使用<code>点运算符（.）</code>轻松访问对象的属性。</p>
<pre><code class="language-go">p.name
//=&gt; Bob
p.age
//=&gt; 42
p.gender
//=&gt; Male
</code></pre>
<p>您还可以使用其指针直接访问结构的属性：</p>
<pre><code class="language-go">pp = &amp;person{name: &quot;Bob&quot;, age: 42, gender: &quot;Male&quot;}
pp.name
//=&gt; Bob
</code></pre>
<h3 id="method">方法（method）</h3>
<p>方法是具有接收器的特殊类型的函数。接收器既可以是值，也可以是指针。让我们创建一个名为describe的方法，它具有我们在上面的例子中创建类型为person的接收器。</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;

// struct defination
type person struct {
  name   string
  age    int
  gender string
}

// method defination
func (p *person) describe() {
  fmt.Printf(&quot;%v is %v years old.&quot;, p.name, p.age)
}
func (p *person) setAge(age int) {
  p.age = age
}

func (p person) setName(name string) {
  p.name = name
}

func main() {
  pp := &amp;person{name: &quot;Bob&quot;, age: 42, gender: &quot;Male&quot;}
  pp.describe()
  // =&gt; Bob is 42 years old
  pp.setAge(45)
  fmt.Println(pp.age)
  //=&gt; 45
  pp.setName(&quot;Hari&quot;)
  fmt.Println(pp.name)
  //=&gt; Bob
}
</code></pre>
<p>正如我们在上面的例子中所看到的，方法<code>describe</code>现在可以使用点运算符来调用该方法<code>pp.describe()</code>。请注意，接收器是指针。使用指针，我们传递对值的引用，因此如果我们对方法进行任何更改，它将反映在接收器<code>pp</code>中。它也不会创建对象的新副本，从而节省了内存。</p>
<p>请注意，在上面的示例中，age的值已更改，而name的值未更改，因为方法setName属于接收器类型，而setAge属于指针类型。</p>
<h3 id="interface">接口（interface）</h3>
<p>Go中的接口是方法的集合。接口有助于将类型的属性组合在一起。我们以接口animal为例：</p>
<pre><code class="language-go">type animal interface {
  description() string
}
</code></pre>
<p>这里的animal是一种接口类型，现在让我们创建两种不同类型的动物来实现animal接口类型。</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
)

type animal interface {
  description() string
}

type cat struct {
  Type  string
  Sound string
}

type snake struct {
  Type      string
  Poisonous bool
}

func (s snake) description() string {
  return fmt.Sprintf(&quot;Poisonous: %v&quot;, s.Poisonous)
}

func (c cat) description() string {
  return fmt.Sprintf(&quot;Sound: %v&quot;, c.Sound)
}

func main() {
  var a animal
  a = snake{Poisonous: true}
  fmt.Println(a.description())
  a = cat{Sound: &quot;Meow!!!&quot;}
  fmt.Println(a.description())
}

//=&gt; Poisonous: true
//=&gt; Sound: Meow!!!
</code></pre>
<p>在main函数中，我们创建一个动物类型的变量a，我们为动物分配蛇和猫类型，并使用Println打印a.description。</p>
<p>由于我们以不同的方式实现了两种类型（猫和蛇）中描述的方法，我们就可以打印动物的描述（description）。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B">鸭子类型 duck typing</a></p>
<h2 id="packages">包（packages）</h2>
<p>我们在Go的包中书写所有的代码。主程序包是程序执行的入口点。这里有许多Go中的内置包。我们一直使用的最着名的是<code>fmt</code>包。</p>
<h3 id="_7">安装包</h3>
<pre><code class="language-shell">go get &lt;package-url-github&gt;
// example
go get github.com/satori/go.uuid
</code></pre>
<p>我们安装的软件包保存在GOPATH env中，这是我们的工作目录。您可以通过<code>cd $GOPATH/pkg</code>进入我们工作目录中的pkg包文件夹。</p>
<h3 id="_8">创建自定义的包</h3>
<p>让我们从创建一个文件夹custom_package开始：</p>
<pre><code class="language-shell">&gt; mkdir custom_package
&gt; cd custom_package
</code></pre>
<p>要创建自定义包，我们需要首先使用我们需要的包名创建一个文件夹。假设我们正在建立一个包<code>person</code>，为此，我们在<code>custom_package</code>文件夹中创建一个名为<code>person</code>的文件夹。</p>
<pre><code class="language-shell">&gt; mkdir person
&gt; cd person
</code></pre>
<p>现在让我们在这个文件夹中创建一个文件<code>person.go</code>。</p>
<pre><code class="language-go">package person
func Description(name string) string {
  return &quot;The person name is: &quot; + name
}
func secretName(name string) string {
  return &quot;Do not share&quot;
}
</code></pre>
<p>我们现在需要安装包，以便可以导入和使用它。</p>
<pre><code class="language-shell">go install
</code></pre>
<p>现在让我们回到<code>custom_package</code>文件夹并创建一个<code>main.go</code>文件。</p>
<pre><code class="language-go">package main
import(
  &quot;custom_package/person&quot;
  &quot;fmt&quot;
)
func main(){ 
  p := person.Description(&quot;Milap&quot;)
  fmt.Println(p)
}
// =&gt; The person name is: Milap
</code></pre>
<p>现在，我们可以导入我们创建的<code>person</code>包并使用函数Description。请注意，我们在包中创建的函数secretName将无法访问（注：Go包访问权限使用函数名首字母大小写区分的）。在Go中，小写字母开头的的函数访问权限是<code>private</code>。</p>
<h3 id="packages-documentation">包文档（Packages Documentation）</h3>
<p>Go内置了对包文档的支持 ，运行以下命令以生成文档：</p>
<pre><code class="language-shell">godoc person Description
</code></pre>
<p>这将为person包内的Description函数生成文档，要查看文档，请使用以下命令运行Web服务器：</p>
<pre><code class="language-shell">godoc -http=&quot;:8080&quot;
</code></pre>
<p>现在转到URL<code>http:// localhost:8080/pkg/</code>并查看我们刚创建的包的文档。</p>
<h3 id="go">Go中的一些内置包</h3>
<h4 id="fmt">fmt</h4>
<p>该包实现了格式化的<code>I / O</code>（输入/输出）功能。我们已经使用过该包打印到stdout。</p>
<h4 id="json">json</h4>
<p>Go中另一个有用的包是json包。它帮助我们编码/解码（encode/decode）Json格式的文件。</p>
<pre><code class="language-go">// Encode
package main

import (
  &quot;fmt&quot;
  &quot;encoding/json&quot;
)

func main(){
  mapA := map[string]int{&quot;apple&quot;: 5, &quot;lettuce&quot;: 7}
  mapB, _ := json.Marshal(mapA)
  fmt.Println(string(mapB))
}
</code></pre>
<pre><code class="language-go">// Decode
package main

import (
  &quot;fmt&quot;
  &quot;encoding/json&quot;
)

type response struct {
  PageNumber int `json:&quot;page&quot;`
  Fruits []string `json:&quot;fruits&quot;`
}

func main(){
  str := `{&quot;page&quot;: 1, &quot;fruits&quot;: [&quot;apple&quot;, &quot;peach&quot;]}`
  res := response{}
  json.Unmarshal([]byte(str), &amp;res)
  fmt.Println(res.PageNumber)
}
//=&gt; 1
</code></pre>
<p>在使用<code>unmarshal</code>解码json字节时，第一个参数是json字节，第二个参数是我们希望json映射到的响应类型struct的地址。请注意<code>json:”page”</code>将json中的page属性映射给struct中PageNumber属性。</p>
<h2 id="error-handling">错误处理（Error Handling）</h2>
<p>errors是程序没有按照预期执行而导致的结果。假设我们正在对外部服务进行API调用，此API调用可能成功或可能失败，当存在错误类型时，Go程序中的错误可以被标记识别出来：</p>
<pre><code class="language-go">resp, err := http.Get(&quot;http://example.com/&quot;)
</code></pre>
<p>这里对错误对象的API调用可能通过或可能失败。我们可以检查错误是否为<code>nil</code>，并相应地处理响应：</p>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;net/http&quot;
)

func main(){
  resp, err := http.Get(&quot;http://example.com/&quot;)
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Println(resp)
}
</code></pre>
<h3 id="_9">给函数返回自定义的错误类型</h3>
<p>当我们编写自己的函数时，有些情况下我们会遇到错误。可以在错误对象的帮助下返回这些错误：</p>
<pre><code class="language-go">func Increment(n int) (int, error) {
  if n &lt; 0 {
    // return error object
    return nil, errors.New(&quot;math: cannot process negative number&quot;)
  }
  return (n + 1), nil
}
func main() {
  num := 5

  if inc, err := Increment(num); err != nil {
    fmt.Printf(&quot;Failed Number: %v, error message: %v&quot;, num, err)
  }else {
    fmt.Printf(&quot;Incremented Number: %v&quot;, inc)
  }
}
</code></pre>
<p>使用Go构建的大多数软件包或我们使用的外部软件包都有一种错误处理机制。所以我们调用的任何函数都可能存在错误。这些错误永远不应该被忽略，并且总是在我们调用这些函数的地方优雅地处理，就像我们在上面的例子中所做的那样。</p>
<h3 id="panic">恐慌（panic）</h3>
<p><code>Panic</code>是在程序执行期间突然发生的未经处理的异常。在Go中，panic不是处理程序中异常的理想方式，建议使用错误对象。发生panic时，程序执行停止。panic之后执行的事情就是defer。</p>
<h3 id="defer">延迟（defer）</h3>
<p>Defer总是在函数结束时执行。</p>
<pre><code class="language-go">//Go
package main

import &quot;fmt&quot;

func main() {
    f()
    fmt.Println(&quot;Returned normally from f.&quot;)
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println(&quot;Recovered in f&quot;, r)
        }
    }()
    fmt.Println(&quot;Calling g.&quot;)
    g(0)
    fmt.Println(&quot;Returned normally from g.&quot;)
}

func g(i int) {
    if i &gt; 3 {
        fmt.Println(&quot;Panicking!&quot;)
        panic(fmt.Sprintf(&quot;%v&quot;, i))
    }
    defer fmt.Println(&quot;Defer in g&quot;, i)
    fmt.Println(&quot;Printing in g&quot;, i)
    g(i + 1)
}
</code></pre>
<p>在上面的例子中，我们使用<code>panic()</code>在执行程序时制造一个<code>panic</code>。正如您所注意到的，有一个延迟语句，它将使程序在程序执行结束时执行该行。当我们需要在函数末尾执行某些操作时，也可以使用Defer，例如关闭文件。</p>
<h2 id="concurrency">并发（Concurrency）</h2>
<p>Go是建立在并发性的基础上的。Go中的并发可以通过轻量级线程的Go routines（协程）来实现。</p>
<h3 id="routine">协程（routine）</h3>
<p>Go routine 是可以与另一个函数并行或同时运行的函数。创建一个Go routine很简单，简单到只需要在函数名前面加一个关键字<code>go</code>即可，我们就可以让这个函数并行执行。Go routines是非常轻量级的，所有我们可以创建成千上万的。让我们来看一个简单的示例：</p>
<pre><code class="language-go">package main
import (
  &quot;fmt&quot;
  &quot;time&quot;
)
func main() {
  go c()
  fmt.Println(&quot;I am main&quot;)
  time.Sleep(time.Second * 2)
}
func c() {
  time.Sleep(time.Second * 2)
  fmt.Println(&quot;I am concurrent&quot;)
}
//=&gt; I am main
//=&gt; I am concurrent
</code></pre>
<p>正如您在上面的示例中看到的那样，函数c是一个Go routine并且它并行的执行在Go的主线程中。有时我们想要在多个线程之间共享资源，Go更喜欢不与另一个线程共享变量，因为这会增加死锁和资源等待的可能性，还有另一种在Go routine之间共享资源的方法：通过 Go 中的 <code>channels</code>。</p>
<h3 id="channels">通道（Channels）</h3>
<p>我们可以使用<code>Channels</code>在两个Go协程之间传递数据。在创建Channel时，必须指定Channels接收的数据类型。</p>
<p>让我们创建一个字符串类型的简单Channel，如下所示：</p>
<pre><code class="language-go">c := make(chan string)
</code></pre>
<p>使用这个Channel，我们可以发送字符串类型数据，并且我们可以同时在此channel中发送和接收数据：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main(){
  c := make(chan string)
  go func(){ c &lt;- &quot;hello&quot; }()
  msg := &lt;-c
  fmt.Println(msg)
}
//=&gt;&quot;hello&quot;
</code></pre>
<p>接收方的channel等待直到发送方的channel发送数据。</p>
<h3 id="one-way-channel">单向的通道（One Way Channel）</h3>
<p>在某些情况下，我们希望Go routine通过channel接收数据但不发送数据，反之亦然。为此，我们还可以创建单向的channel。</p>
<pre><code class="language-go">
package main

import (
 &quot;fmt&quot;
)

func main() {
 ch := make(chan string)

 go sc(ch)
 fmt.Println(&lt;-ch)
}

func sc(ch chan&lt;- string) {
 ch &lt;- &quot;hello&quot;
}
</code></pre>
<p>在上面的例子中，sc是一个Go routine，它只能向channel发送消息但不能接收消息。</p>
<h3 id="selectgo-routinechannel">使用select为Go routine组织多个channel</h3>
<p>函数可能有多个channel正在等待。为此，我们可以使用select语句。让我们看一个更清晰的例子：</p>
<pre><code class="language-go">package main

import (
 &quot;fmt&quot;
 &quot;time&quot;
)

func main() {
 c1 := make(chan string)
 c2 := make(chan string)
 go speed1(c1)
 go speed2(c2)
 fmt.Println(&quot;The first to arrive is:&quot;)
 select {
 case s1 := &lt;-c1:
  fmt.Println(s1)
 case s2 := &lt;-c2:
  fmt.Println(s2)
 }
}

func speed1(ch chan string) {
 time.Sleep(2 * time.Second)
 ch &lt;- &quot;speed 1&quot;
}

func speed2(ch chan string) {
 time.Sleep(1 * time.Second)
 ch &lt;- &quot;speed 2&quot;
}
</code></pre>
<p>在上面这个列子中，在主线程中有两个等待的channels，c1和c2。在主函数中使用<code>select case</code>打印从通道中发送的消息，无论先收到谁。</p>
<h3 id="buffered-channel">带缓冲的通道（Buffered channel）</h3>
<p>有些情况下我们需要向通道发送多个数据。您可以为此创建缓冲通道。使用缓冲通道，接收器在缓冲区已满之前不会收到消息。让我们来看看这个例子：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main(){
  ch := make(chan string, 2)
  ch &lt;- &quot;hello&quot;
  ch &lt;- &quot;world&quot;
  fmt.Println(&lt;-ch)
}
</code></pre>
<h2 id="great">Great!</h2>
<p>我们了解了Go的一些主要组件和功能。</p>
<ol>
<li>Variables, Datatypes</li>
<li>Array slices and maps</li>
<li>Functions</li>
<li>Looping and conditional statements</li>
<li>Pointers</li>
<li>Packages</li>
<li>Method, Structs, and Interfaces</li>
<li>Error Handling</li>
<li>Concurrency — Go routines and channels</li>
</ol>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../git/Git%E9%80%9F%E6%9F%A5%E8%A1%A8/" class="btn btn-neutral float-left" title="Git速查表"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../../groovy/Groovy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="btn btn-neutral float-right" title="Groovy学习笔记">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/simplepeng/KeepLearning/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../../git/Git%E9%80%9F%E6%9F%A5%E8%A1%A8/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../../groovy/Groovy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
